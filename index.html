<script src=lib10.js></script>
<script src=math.js></script>
<script src=matrix.js></script>
<script src=geometry.js></script>
<script src=implicitSurface.js></script>

<body bgcolor=black text=white link=white alink=white vlink=white>
<center>
<canvas id='canvas1' width=800 height=800></canvas>
</center>
</body>


<!!-------- VERTEX SHADER -------->

<script id='my_vertex_shader' type='x-shader/x-vertex'>
   uniform   float uTime;
   uniform   mat4  uMatrix, uInvMatrix, uCamera;
   attribute vec3  aPos;
   attribute vec3  aNor;
   varying   vec3  vPos;
   varying   vec3  vNor;
   void main() {

      // CAMERA MATRIX IS APPLIED AFTER ALL OTHER TRANSFORMATIONS.
      // THAT IS WHY IT MULTIPLIES FROM THE LEFT.

      vec4 pos = uCamera * uMatrix * vec4(aPos, 1.);

      // NORMAL IS RIGHT-MULTIPLIED BY INVERSE OF MATRIX.

      vec4 nor = vec4(aNor, 0.) * uInvMatrix;
      gl_Position = pos;
      vPos = pos.xyz;
      vNor = nor.xyz;
   }
</script>


<!!-------- FRAGMENT SHADER -------->

<script id='my_fragment_shader' type='x-shader/x-fragment'>

 uniform float uTime;   // TIME, IN SECONDS

 varying vec3 vPos;
 varying vec3 vNor;

 float fl = 3.0;

 const int nl = 2; // NUMBER OF LIGHTS
 const int ns = 2; // NUMBER OF SPHERES

 uniform vec3 uLDir[nl];
 uniform vec3 uLCol[nl];

 uniform vec3 uAmbient;
 uniform vec3 uDiffuse;
 uniform vec4 uSpecular;

 void main() {
    vec3 N = normalize(vNor);

    // WE DO PHONG SHADING HERE ONLY FOR MATERIAL 0.

    vec3 color = uAmbient;
    for (int n = 0 ; n < nl ; n++) {
       vec3 R = 2. * dot(uLDir[n], N) * N - uLDir[n];
       color += uLCol[n] * (
                 uDiffuse * max(0., dot(uLDir[n], N))
               + uSpecular.rgb * pow(max(0., R.z), uSpecular.w)
       );
    }
    gl_FragColor = vec4(sqrt(color), 1.0);
 }
</script>


<!!-------- A PROPERLY DESCRIPTIVE TITLE -------->

<script id='my_title' type='text/html'>
FINAL PROJECT
</script>


<!!-------- HERE IS WHERE YOU CAN PROVIDE A LONGER TEXT DESCRIPTION -------->

<script id='my_instructions' type='text/html'><font color=#b0b0b0>
This is a simple example<br>
of of an implicit surface<br>
</script>


<!!-------- GENERAL SUPPORT CODE -------->

<script>

// CREATE THE HTML DOCUMENT

let vs = my_vertex_shader.innerHTML,
    fs = my_fragment_shader.innerHTML;
    fs = fs.substring(1, fs.length);

document.body.innerHTML = [''
   ,'<center><font size=6 color=#b0b0b0>' + my_title.innerHTML + '</center>'
   ,'<TABLE cellspacing=0 cellpadding=0><TR>'
   ,'<td width=50></td><td><font color=red size=5><div id=errorMessage>&nbsp;</div></font></td>'
   ,'</TR><TR>'
   ,'<table cellspacing=10>'
   ,'<tr>'
   ,'<td valign=top><font size=2 color=red><div id=errorMarker>&nbsp;</div></font></td>'
   ,'<td valign=top>'
   // ,'<textArea id=textArea spellcheck=false '
   // ,'style="font:16px courier;outline-width:0;border-style:none;resize:none;overflow:scroll;"'
   // ,'></textArea>'
   ,'</td><td valign=top>' + document.body.innerHTML + '</td>'
   ,'<td valign=top><font size=5>' + my_instructions.innerHTML + '</td>'
   ,'</tr></table>'
   ,'</TR></TABLE>'
   ].join('');

//----------- SET UP THE EDITABLE TEXT AREA ON THE LEFT SIDE.

// let text = fs.split('\n'), cols = 0;
// for (let i = 0 ; i < text.length ; i++)
//    cols = Math.max(cols, text[i].length);
//
// textArea.rows = text.length;
// textArea.cols = cols;
// textArea.value = fs;
// textArea.style.backgroundColor = '#202020';
// textArea.style.color = 'white';
//
// //----------- REPARSE THE SHADER PROGRAM AFTER EVERY KEYSTROKE.
//
// textArea.onkeyup = function() { canvas1.setShaders(vs, this.value); }

let startTime = Date.now();

let r3 = Math.sqrt(1/3);

//----------- DEFINE MATERIALS

materials['black'  ] = { ambient: [.0,.0,.0], diffuse: [0,0,0], specular: [.9,.9,.9,10] };
materials['blue'   ] = { ambient: [.0,.0,.2], diffuse: [0,0,1], specular: [.9,.9,.9,10] };
materials['brass'  ] = { ambient: [.03,.02,.01], diffuse: [.03,.02,.01], specular: [.9,.6,.3,10] };
materials['cyan'   ] = { ambient: [.0,.15,.15], diffuse: [0,.075,.075], specular: [0,.7,.7,10] };
materials['gold'   ] = { ambient: [.2,.15,0], diffuse: [.1,.075,0], specular: [1,.7,.0,10] };
materials['green'  ] = { ambient: [.0,.1,.0], diffuse: [0,.5,0], specular: [.6,.6,.6,10] };
materials['magenta'] = { ambient: [.1,.0,.1], diffuse: [.5,0,.5], specular: [.6,.0,.6,10] };
materials['red'    ] = { ambient: [.2,.0,.0], diffuse: [1,0,0], specular: [.9,.9,.9,10] };
materials['steel'  ] = { ambient: [.03,.03,.03], diffuse: [.03,.03,.03], specular: [1,1,1,15] };
materials['white'  ] = { ambient: [.2,.2,.2], diffuse: [1,1,1], specular: [.9,.9,.9,10] };
materials['yellow' ] = { ambient: [.2,.2,.0], diffuse: [1,1,0], specular: [.9,.9,.0,10] };
materials['skin' ] = { ambient: [.1,.0859,0.0675], diffuse: [1,0.859,0.675], specular: [1,0.859,0.675] };
materials['tongue' ] = { ambient: [.1,.0212,0.0608], diffuse: [1,0.212,0.608], specular: [1,0.212,0.608,0.675] };
materials['water' ] = { ambient: [0.05137,0.08431,0.09333], diffuse: [0.5137,0.8431,0.9333], specular: [0.5137,0.8431,0.9333,100] };

//----------- DEFINE THE HERMITE SPLINE CURVE DATA

let hx = [ -.5,  0.0,     0,  0.8,    .5,  0.0,    0, -0.8,   -.5,  0.0 ];
let hy = [   0, -0.8,   -.5,  0.0,     0,  0.8,   .5,  0.0,     0, -0.8 ];
let hz = [   0,  0.0,     0,  0.0,     0,  0.0,    0,  0.0,     0,  0.0 ];

//----------- FOCAL LENGTH OF CAMERA

let fl = 3;


// GAME MODE - 0 - GAME,  1 - GAME OVER
let gameOver = false;

// HIT TESTING OF 2 SPHERES
let sphereHitsSphere = (S1, S2, r1, r2, caseNumber) => {
   let d =  Math.pow(S1[0]-S2[0], 2)
          + Math.pow(S1[1]-S2[1], 2)
          + Math.pow(S1[2]-S2[2], 2);
   d = Math.sqrt(d);

   if((d <= (r1 + r2)) == true)
      console.log(caseNumber);

   if(!gameOver)
      gameOver = (d <= (r1 + r2));
   return ;
}

//----------- FIND OUT WHETHER A RAY HITS A SPHERE

let rayHitsSphere = (V, W, S) => {
   let Vp = [ V[0] - S[0], V[1] - S[1], V[2] - S[2] ];
   let vw = dot(Vp, W);
   let d = vw * vw - dot(Vp, Vp) + S[3] * S[3];
   return d > 0;
}

let lerp = (a,b,t) => a + t * (b - a); // LINEAR INTERPOLATION

// TIMING TABLE FOR THE ANIMATION SEQUENCE

let timing = [
   [0, 0.5],
];

// EASE CURVE TO ACCELERATE FROM REST AND THEN DECELERATE TO REST

let sCurve = t => (3 - 2 * t) * t * t;

// EVALUATE THE TIMING OF ONE ANIMATION PARAMETER FOR THIS FRAME

let evalTiming = n => {
   let t0 = timing[n][0];
   let t1 = timing[n][1];

   if (animationTime < t0)
      return 0;
   if (animationTime > t1)
      return 1;
   return sCurve((animationTime - t0) / (t1 - t0));
}

// CONVERT BETWEEN SLIDER POSITION AND VALUE RANGE BETWEEN 0.0 AND 1.0

let sliderToT = s => Math.max(0, 10 * (sw/2 + s));
let tToSlider = t => Math.max(sr-sw, Math.min(sw-sr, t / 10 - sw/2));

let animationTime = 0, animationRunning = false, prevTime = 0, maxTime = 0.5;

//----------- ANIMATE EACH FRAME

function animate(gl) {

   let time = (Date.now() - startTime) / 1000;

   if(animationRunning) {
     animationTime += time - prevTime;
     prevTime = time;
     if(animationTime > maxTime) {
       animationRunning = false;
       animationTime = 0;
       prevTime = 0;
     }
   } else {
     prevTime = time;
   }

   // TIMING
   // EVALUATE ALL ANIMATION TIMING PARAMETERS

   let T = [];
   for (let i = 0 ; i < timing.length ; i++)
      T[i] = evalTiming(i);

   // SET ANIMATION TIME IN FRAGMENT SHADER

   setUniform('1f', 'uTime', time);

   // SET LIGHT POSITION AND COLOR FOR RAYTRACING

   setUniform('3fv', 'uLDir', [r3,r3,r3, -r3,-r3,-r3]);
   setUniform('3fv', 'uLCol', [.6,.8,1, .4,.3,.2]);

   // SET SURFACE REFLECTANCE PROPERTIES

   setUniform('3fv', 'uAmbient' , [.2,.2,.2]);
   setUniform('3fv', 'uDiffuse' , [1,1,1]);
   setUniform('4fv', 'uSpecular', [.9,.9,.9,10]);

   setUniform('Matrix4fv', 'uCamera', false, matrix_perspective(3));

   let implicitFunction = (x,y,z,args) => {
      let a = blob( [0, 0, 0.25], 0.28, x,y,z );            // head

      let b = blob( [0.24, 0.32, 0.25], 0.1, x,y,z );    // ear 1

      let c = blob( [-0.24, 0.32, 0.25], 0.1, x,y,z );      // ear 2

      let d = blob( [0, -0.1, 0.5], 0.1, x,y,z );    // cheek 1

      let f = blob( [0, -0.3, 0.08], 0.15, x,y,z );   // neck

      let g1 = blob([0, -0.45, -0.25], 0.3, x, y, z);   //body
      let h1 = blob([0, -0.45, -0.75], 0.3, x, y, z);     // body

      let m = blob( [0, -0.2, -0.85], 0.1, x,y,z );    // tail
      let n = blob( [0, 0, -0.85], 0.1, x,y,z );   // tail
      let m1 = blob( [0, 0.2, -0.85], 0.1, x,y,z );    // tail

      return a*a*a*a + b*b*b*b + c*c*c*c + d*d*d*d + f*f*f*f
      + g1*g1*g1*g1 + h1*h1*h1*h1
       + m*m*m*m + n*n*n*n + m1*m1*m1*m1 - 0.5;
   }

   let implicitFunction2 = (x,y,z,args) => {
      let a = blob( [0, 0, 0.45], 0.28, x,y,z );            // head

      let b = blob( [0.24, 0.32, 0.45], 0.1, x,y,z );    // ear 1

      let c = blob( [-0.24, 0.32, 0.45], 0.1, x,y,z );      // ear 2

      let d = blob( [0, -0.3, 0.5], 0.1, x,y,z );    // cheek 1

      let f = blob( [0, -0.4, 0.12], 0.15, x,y,z );   // neck

      let g1 = blob([0, -0.45, -0.25], 0.3, x, y, z);   //body
      let h1 = blob([0, -0.45, -0.75], 0.3, x, y, z);     // body

      let m = blob( [0, -0.2, -0.85], 0.1, x,y,z );    // tail
      let n = blob( [0, 0, -0.85], 0.1, x,y,z );   // tail
      let m1 = blob( [0, 0.2, -0.85], 0.1, x,y,z );    // tail

      let i1 = blob([0.15, -1, -0.2], 0.1, x, y, z);   // front leg 1
      let j1 = blob([0.15, -0.8, -0.2], 0.1, x, y, z);     // front leg 2

      let i2 = blob([-0.15, -1, -0.2], 0.1, x, y, z);   // front leg 1
      let j2 = blob([-0.15, -0.8, -0.2], 0.1, x, y, z);     // front leg 2

      let i3 = blob([0.15, -1, -0.75], 0.1, x, y, z);   // back leg 1
      let j3 = blob([0.15, -0.8, -0.75], 0.1, x, y, z);     // back leg 2

      let i4 = blob([-0.15, -1, -0.75], 0.1, x, y, z);   // back leg 1
      let j4 = blob([-0.15, -0.8, -0.75], 0.1, x, y, z);     // back leg 2

      return a*a*a*a + b*b*b*b + c*c*c*c + d*d*d*d + f*f*f*f
      + g1*g1*g1*g1 + h1*h1*h1*h1
       + i1*i1*i1*i1 + j1*j1*j1*j1 + i2*i2*i2*i2 + j2*j2*j2*j2
       + i3*i3*i3*i3 + j3*j3*j3*j3 + i4*i4*i4*i4 + j4*j4*j4*j4
       + m*m*m*m + n*n*n*n + m1*m1*m1*m1 - 0.5;
   }


   var ballS1 = [];
   var ballRadius1 = 0.1;
   var ballS2 = [];
   var ballRadius2 = 0.1;
   var ballS3 = [];
   var ballRadius3 = 0.1;
   var ballS4 = [];
   var ballRadius4 = 0.1;

   var numberOfObstacles = 2;

   let divs = 24;

   let timeColor = time - Math.floor(time);

   if(gameOver) {
     M.save();

        // GAME OVER
        M.save();
        M.save();
           M.translate(-0.8, 0.8, 0);
           M.scale(1.2);

           // G
           M.save();
              M.rotateX(Math.PI/2);
              M.scale(0.03,0.03,0.08);
              drawMesh2(cylinderMesh, false,
               [timeColor/10,timeColor/10,timeColor/10],
                [timeColor,timeColor,timeColor],
                 [timeColor,timeColor,timeColor,10]);
           M.restore();
           M.save();
              M.translate(0.06,0.06,0);
              M.rotateY(Math.PI/2);
              M.scale(0.03,0.03,0.05);
              drawMesh2(cylinderMesh, false,
               [timeColor/10,timeColor/10,timeColor/10],
                [timeColor,timeColor,timeColor],
                 [timeColor,timeColor,timeColor,10]);
           M.restore();
           M.save();
              M.translate(0.06,-0.06,0);
              M.rotateY(Math.PI/2);
              M.scale(0.03,0.03,0.05);
              drawMesh2(cylinderMesh, false,
               [timeColor/10,timeColor/10,timeColor/10],
                [timeColor,timeColor,timeColor],
                 [timeColor,timeColor,timeColor,10]);
           M.restore();
           M.save();
              M.rotateX(Math.PI/2);
              M.translate(0.08,-0.05,0);
              M.scale(0.02,0.02,0.03);
              drawMesh2(cylinderMesh, false,
               [timeColor/10,timeColor/10,timeColor/10],
                [timeColor,timeColor,timeColor],
                 [timeColor,timeColor,timeColor,10]);
           M.restore();

           // A
           M.save();
           M.translate(0.17,0,0);
           M.save();
              M.rotateX(Math.PI/2);
              M.scale(0.03,0.03,0.08);
              drawMesh2(cylinderMesh, false,
               [timeColor/10,timeColor/10,timeColor/10],
                [timeColor,timeColor,timeColor],
                 [timeColor,timeColor,timeColor,10]);
           M.restore();
           M.save();
              M.translate(0.05,0.06,0);
              M.rotateY(Math.PI/2);
              M.scale(0.03,0.03,0.03);
              drawMesh2(cylinderMesh, false,
               [timeColor/10,timeColor/10,timeColor/10],
                [timeColor,timeColor,timeColor],
                 [timeColor,timeColor,timeColor,10]);
           M.restore();
           M.save();
              M.translate(0.05,-0.01,0);
              M.rotateY(Math.PI/2);
              M.scale(0.03,0.03,0.03);
              drawMesh2(cylinderMesh, false,
               [timeColor/10,timeColor/10,timeColor/10],
                [timeColor,timeColor,timeColor],
                 [timeColor,timeColor,timeColor,10]);
           M.restore();
           M.save();
              M.translate(0.1,0,0);
              M.rotateX(Math.PI/2);
              M.scale(0.03,0.03,0.08);
              drawMesh2(cylinderMesh, false,
               [timeColor/10,timeColor/10,timeColor/10],
                [timeColor,timeColor,timeColor],
                 [timeColor,timeColor,timeColor,10]);
           M.restore();
           M.restore();

           // M
           M.save();
           M.translate(0.35,0,0);
           M.save();
              M.rotateX(Math.PI/2);
              M.scale(0.03,0.03,0.08);
              drawMesh2(cylinderMesh, false,
               [timeColor/10,timeColor/10,timeColor/10],
                [timeColor,timeColor,timeColor],
                 [timeColor,timeColor,timeColor,10]);
           M.restore();
           M.save();
              M.translate(0.06,0.06,0);
              M.rotateY(Math.PI/2);
              M.scale(0.03,0.03,0.04);
              drawMesh2(cylinderMesh, false,
               [timeColor/10,timeColor/10,timeColor/10],
                [timeColor,timeColor,timeColor],
                 [timeColor,timeColor,timeColor,10]);
           M.restore();
           M.save();
              M.rotateX(Math.PI/2);
              M.translate(0.06,-0.01,0);
              M.scale(0.02,0.03,0.03);
              drawMesh2(cylinderMesh, false,
               [timeColor/10,timeColor/10,timeColor/10],
                [timeColor,timeColor,timeColor],
                 [timeColor,timeColor,timeColor,10]);
           M.restore();
           M.save();
              M.translate(0.12,0,0);
              M.rotateX(Math.PI/2);
              M.scale(0.03,0.03,0.08);
              drawMesh2(cylinderMesh, false,
               [timeColor/10,timeColor/10,timeColor/10],
                [timeColor,timeColor,timeColor],
                 [timeColor,timeColor,timeColor,10]);
           M.restore();
           M.restore();


           // E
           M.save();
           M.translate(0.55,0,0);
           M.save();
              M.rotateX(Math.PI/2);
              M.scale(0.03,0.03,0.08);
              drawMesh2(cylinderMesh, false,
               [timeColor/10,timeColor/10,timeColor/10],
                [timeColor,timeColor,timeColor],
                 [timeColor,timeColor,timeColor,10]);
           M.restore();
           M.save();
              M.translate(0.05,0.06,0);
              M.rotateY(Math.PI/2);
              M.scale(0.03,0.03,0.06);
              drawMesh2(cylinderMesh, false,
               [timeColor/10,timeColor/10,timeColor/10],
                [timeColor,timeColor,timeColor],
                 [timeColor,timeColor,timeColor,10]);
           M.restore();
           M.save();
              M.translate(0.05,0,0);
              M.rotateY(Math.PI/2);
              M.scale(0.02,0.02,0.03);
              drawMesh2(cylinderMesh, false,
               [timeColor/10,timeColor/10,timeColor/10],
                [timeColor,timeColor,timeColor],
                 [timeColor,timeColor,timeColor,10]);
           M.restore();
           M.save();
              M.translate(0.05,-0.06,0);
              M.rotateY(Math.PI/2);
              M.scale(0.03,0.03,0.06);
              drawMesh2(cylinderMesh, false,
               [timeColor/10,timeColor/10,timeColor/10],
                [timeColor,timeColor,timeColor],
                 [timeColor,timeColor,timeColor,10]);
           M.restore();
           M.restore();

           // O
           M.save();
              M.translate(0.85,0,0);
              M.scale(0.06);
              drawMesh2(torusMesh, false,
               [timeColor/10,timeColor/10,timeColor/10],
                [timeColor,timeColor,timeColor],
                 [timeColor,timeColor,timeColor,10]);
           M.restore();

           // V
           M.save();
           M.translate(1,0,0);
           M.save();
              M.rotateX(Math.PI/2);
              M.rotateY(Math.PI/6);
              M.scale(0.03,0.03,0.08);
              drawMesh2(cylinderMesh, false,
               [timeColor/10,timeColor/10,timeColor/10],
                [timeColor,timeColor,timeColor],
                 [timeColor,timeColor,timeColor,10]);
           M.restore();
           M.save();
              M.translate(0.07,0,0);
              M.rotateX(Math.PI/2);
              M.rotateY(-Math.PI/6);
              M.scale(0.03,0.03,0.08);
              drawMesh2(cylinderMesh, false,
               [timeColor/10,timeColor/10,timeColor/10],
                [timeColor,timeColor,timeColor],
                 [timeColor,timeColor,timeColor,10]);
           M.restore();
           M.restore();

           // E
           M.save();
           M.translate(1.17,0,0);
           M.save();
              M.rotateX(Math.PI/2);
              M.scale(0.03,0.03,0.08);
              drawMesh2(cylinderMesh, false,
               [timeColor/10,timeColor/10,timeColor/10],
                [timeColor,timeColor,timeColor],
                 [timeColor,timeColor,timeColor,10]);
           M.restore();
           M.save();
              M.translate(0.05,0.06,0);
              M.rotateY(Math.PI/2);
              M.scale(0.03,0.03,0.06);
              drawMesh2(cylinderMesh, false,
               [timeColor/10,timeColor/10,timeColor/10],
                [timeColor,timeColor,timeColor],
                 [timeColor,timeColor,timeColor,10]);
           M.restore();
           M.save();
              M.translate(0.05,0,0);
              M.rotateY(Math.PI/2);
              M.scale(0.02,0.02,0.03);
              drawMesh2(cylinderMesh, false,
               [timeColor/10,timeColor/10,timeColor/10],
                [timeColor,timeColor,timeColor],
                 [timeColor,timeColor,timeColor,10]);
           M.restore();
           M.save();
              M.translate(0.05,-0.06,0);
              M.rotateY(Math.PI/2);
              M.scale(0.03,0.03,0.06);
              drawMesh2(cylinderMesh, false,
               [timeColor/10,timeColor/10,timeColor/10],
                [timeColor,timeColor,timeColor],
                 [timeColor,timeColor,timeColor,10]);
           M.restore();
           M.restore();

           // R
           M.save();
           M.translate(1.34,0,0);
           M.save();
              M.rotateX(Math.PI/2);
              M.scale(0.03,0.03,0.08);
              drawMesh2(cylinderMesh, false,
               [timeColor/10,timeColor/10,timeColor/10],
                [timeColor,timeColor,timeColor],
                 [timeColor,timeColor,timeColor,10]);
           M.restore();
           M.save();
              M.translate(0.05,0.06,0);
              M.rotateY(Math.PI/2);
              M.scale(0.03,0.03,0.03);
              drawMesh2(cylinderMesh, false,
               [timeColor/10,timeColor/10,timeColor/10],
                [timeColor,timeColor,timeColor],
                 [timeColor,timeColor,timeColor,10]);
           M.restore();
           M.save();
              M.translate(0.05,-0.01,0);
              M.rotateY(Math.PI/2);
              M.scale(0.025,0.025,0.025);
              drawMesh2(cylinderMesh, false,
               [timeColor/10,timeColor/10,timeColor/10],
                [timeColor,timeColor,timeColor],
                 [timeColor,timeColor,timeColor,10]);
           M.restore();
           M.save();
              M.translate(0.08,0.03,0);
              M.rotateX(Math.PI/2);
              M.scale(0.03,0.03,0.03);
              drawMesh2(cylinderMesh, false,
               [timeColor/10,timeColor/10,timeColor/10],
                [timeColor,timeColor,timeColor],
                 [timeColor,timeColor,timeColor,10]);
           M.restore();
           M.save();
              M.translate(0.05,-0.03,0);
              M.rotateY(Math.PI/2);
              M.rotateX(Math.PI/5);
              M.scale(0.025,0.025,0.06);
              drawMesh2(cylinderMesh, false,
               [timeColor/10,timeColor/10,timeColor/10],
                [timeColor,timeColor,timeColor],
                 [timeColor,timeColor,timeColor,10]);
           M.restore();
           M.restore();


        M.restore();

        M.scale(0.7);
        let implicitSurfaceMesh = implicitSurfaceTriangleMesh(implicitFunction2, divs,
           [] );
        drawMesh(implicitSurfaceMesh, 'skin', true);

        M.save();
          M.translate(-0.12,0,0.68);
          M.scale(0.06,0.07,0.05);
          drawMesh(sphereMesh, 'black', false);
        M.restore();
        M.save();
           M.translate(-0.12,-0.1,0.68);
           M.scale(0.03,0.06,0.03);
           drawMesh(sphereMesh, 'water', false);
           M.translate(0,-3,0);
           drawMesh(sphereMesh, 'water', false);
        M.restore();
        M.save();
          M.translate(0.12,0,0.68);
          M.scale(0.06,0.07,0.05);
          drawMesh(sphereMesh, 'black', false);
        M.restore();
        M.save();
           M.translate(0.12,-0.1,0.68);
           M.scale(0.03,0.06,0.03);
           drawMesh(sphereMesh, 'water', false);
           M.translate(0,-3,0);
           drawMesh(sphereMesh, 'water', false);
        M.restore();
        M.save();
          M.translate(0,-0.3,0.69);
          M.scale(0.08,0.05,0.05);
          drawMesh(sphereMesh, 'brass', false);
        M.restore();

        M.save();
          M.translate(0,-0.3,0.2);
          M.scale(0.2);
          M.rotateX(3*Math.PI/4);
          drawMesh(torusMesh, 'red', false);
        M.restore();

        M.save();
          M.translate(0,-0.3,0.55);
          M.scale(0.07,0.16,0.1);
          M.rotateX(3*Math.PI/4);
          drawMesh(diskMesh, 'tongue', false);
        M.restore();
     M.restore();
     return ;
   }

   M.save();
      M.save();
         M.translate(0,1,1);
         M.scale(2.5);
         drawMesh(cubeMesh, 'yellow', false);
      M.restore();
      M.save();
        M.translate(0,0.4*Math.sin(Math.PI*T[0])-0.45,0);
        M.scale(0.1);
        M.rotateY(Math.PI/2);
        M.translate(0,0.5,0.3);
         let implicitSurfaceMesh = implicitSurfaceTriangleMesh(implicitFunction, divs,
            [] );
         M.rotateX(Math.cos(10*time)/10);
         drawMesh(implicitSurfaceMesh, 'skin', true);
         M.save();
           M.translate(-0.1,0.1,0.47);
           M.scale(0.05);
           drawMesh(sphereMesh, 'black', false);
         M.restore();
         M.save();
           M.translate(0.1,0.1,0.47);
           M.scale(0.05);
           drawMesh(sphereMesh, 'black', false);
         M.restore();
         M.save();
           M.translate(0,0,0.62);
           M.scale(0.08,0.05,0.05);
           drawMesh(sphereMesh, 'brass', false);
         M.restore();

         M.save();
           M.translate(0,-0.3,0);
           M.scale(0.2);
           M.rotateX(3*Math.PI/4);
           drawMesh(torusMesh, 'red', false);
         M.restore();

         M.save();
           M.translate(0,-0.3,0.55);
           M.scale(0.07,0.16,0.1);
           M.rotateX(3*Math.PI/4);
           drawMesh(diskMesh, 'tongue', false);
         M.restore();

         // FRONT LEGS
         M.save();
               M.translate(-0.1,-0.7,0);
               M.rotateX(Math.PI/2 + Math.sin(10*time)/2);
               M.save();
                  M.scale(0.1,0.1,0.2);
                  drawMesh(sphereMesh, 'white', false);
               M.restore();
               M.save();
                  M.translate(0,0.1,0.2);
                  M.scale(0.1,0.15,0.1);
                  let m1 = M.value();
                  ballS1 = [m1[12], m1[13], m1[14]];
                  ballRadius1 = 0.01;
                  drawMesh(sphereMesh, 'white', false);
               M.restore();
         M.restore();
         M.save();
               M.translate(0.1,-0.7,0);
               M.rotateX(Math.PI/2 + Math.sin(10*time)/2);
               M.save();
                  M.scale(0.1,0.1,0.2);
                  drawMesh(sphereMesh, 'white', false);
               M.restore();
               M.save();
                  M.translate(0,0.1,0.2);
                  M.scale(0.1,0.15,0.1);
                  let m2 = M.value();
                  ballS2 = [m2[12], m2[13], m2[14]];
                  ballRadius2 = 0.01;
                  drawMesh(sphereMesh, 'white', false);
               M.restore();
         M.restore();

         // BACK LEGS
         M.save();
               M.translate(-0.2,-0.7,-0.8);
               M.rotateX(Math.PI/2 + Math.cos(10*time));
               M.save();
                  M.scale(0.1,0.1,0.2);
                  drawMesh(sphereMesh, 'white', false);
               M.restore();
               M.save();
                  M.translate(0,0.1,0.2);
                  M.scale(0.1,0.15,0.1);
                  let m3 = M.value();
                  ballS3 = [m3[12], m3[13], m3[14]];
                  ballRadius3 = 0.01;
                  drawMesh(sphereMesh, 'white', false);
               M.restore();
         M.restore();
         M.save();
               M.translate(0.2,-0.7,-0.8);
               M.rotateX(Math.PI/2 + Math.cos(10*time));
               M.save();
                  M.scale(0.1,0.1,0.2);
                  drawMesh(sphereMesh, 'white', false);
               M.restore();
               M.save();
                  M.translate(0,0.1,0.2);
                  M.scale(0.1,0.15,0.1);
                  let m4 = M.value();
                  ballS4 = [m4[12], m4[13], m4[14]];
                  ballRadius4 = 0.01;
                  drawMesh(sphereMesh, 'white', false);
               M.restore();
         M.restore();

      M.restore();
      for(let i=0;i<numberOfObstacles;i++) {
         M.save();
            var sizeOfObstacle = 0.05 + i/30;
            M.translate(3.2*(0.5 - ((time+(2*i))/4 - Math.floor((time+(2*i))/4))),-0.5,0);
            M.scale(0.05,sizeOfObstacle,0.05);
            M.rotateX(Math.PI/2);
            var m5 = M.value();
            sphereHitsSphere([m5[12], m5[13], m5[14]], ballS1, sizeOfObstacle, ballRadius1,1);
            sphereHitsSphere([m5[12], m5[13], m5[14]], ballS2, sizeOfObstacle, ballRadius2,2);
            sphereHitsSphere([m5[12], m5[13], m5[14]], ballS3, sizeOfObstacle, ballRadius3,3);
            sphereHitsSphere([m5[12], m5[13], m5[14]], ballS4, sizeOfObstacle, ballRadius4,4);
            drawMesh(cylinderMesh, 'blue', false);
         M.restore();
      }
      M.save();
         M.translate(0,-1.7,0);
         M.scale(1.2);
         M.rotateY(Math.PI/2);
         drawMesh(cylinderMesh, 'blue', false);
      M.restore();
   M.restore();
}

let blob = (center, radius, x, y, z) => {
   x -= center[0];
   y -= center[1];
   z -= center[2];
   return Math.max(0, 1 - .16 * (x*x + y*y + z*z) / (radius * radius));
}


let implicitFunction = (x,y,z,args) => {
   let a = blob( [args[0], 0, 0], 0.28, x,y,z );

   return a*a*a*a - 0.5;
}

// HELPER FUNCTIONS FOR ANIMATION

let bounce = t => Math.sin(Math.PI * t);
let wiggle = t => Math.sin(6 * Math.PI * t);

// RESPOND TO MOUSE EVENTS ON THE CANVAS

canvas1.onPress = (x,y) => {
   cx = x;
   cy = y;
   doHitTesting();
}

canvas1.onDrag = (x,y) => {
   cx = x;
   cy = y;
}

canvas1.onRelease = (x,y) => {
   cx = x;
   cy = y;
   setValue(0);
   selected = -1;
}

canvas1.onMove = (x,y) => {
   cx = x;
   cy = y;
   selected = -1;
}

// RECORD WHETHER ANY KEY IS PRESSED

let isKeyPressed = false;
canvas1.onKeyPress   = k => isKeyPressed = true;
canvas1.onKeyRelease = k => isKeyPressed = false;

// RECORD WHETHER MOUSE IS PRESSED
let isMousePressed = false;
canvas1.onPress   = (x,y) => {isMousePressed = true; animationRunning = true; gameOver = false;}
canvas1.onRelease = (x,y) => {isMousePressed = false; same = false;}

// START EVERYTHING

gl_start(canvas1, vs, fs);
</script>
